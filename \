#include "gameboy.h"
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>

// ================ HARDWARE ================

Register regs[REGISTER_COUNT] = {0};
CartridgeHeader cartridge_header = {0};
bool display[160][144] = {0};
uint8_t ram[8192] = {0};
uint8_t vram[8192] = {0};
uint8_t io_registers[128] = {0};
int cycle = 0;
bool prefix = false;

// bootix bootrom: https://github.com/Hacktix/Bootix
uint8_t boot_rom[256] = {
    0x31, 0xfe, 0xff, 0x21, 0xff, 0x9f, 0xaf, 0x32, 0xcb, 0x7c, 0x20, 0xfa,
    0x0e, 0x11, 0x21, 0x26, 0xff, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3,
    0x32, 0xe2, 0x0c, 0x3e, 0x77, 0x32, 0xe2, 0x11, 0x04, 0x01, 0x21, 0x10,
    0x80, 0x1a, 0xcd, 0xb8, 0x00, 0x1a, 0xcb, 0x37, 0xcd, 0xb8, 0x00, 0x13,
    0x7b, 0xfe, 0x34, 0x20, 0xf0, 0x11, 0xcc, 0x00, 0x06, 0x08, 0x1a, 0x13,
    0x22, 0x23, 0x05, 0x20, 0xf9, 0x21, 0x04, 0x99, 0x01, 0x0c, 0x01, 0xcd,
    0xb1, 0x00, 0x3e, 0x19, 0x77, 0x21, 0x24, 0x99, 0x0e, 0x0c, 0xcd, 0xb1,
    0x00, 0x3e, 0x91, 0xe0, 0x40, 0x06, 0x10, 0x11, 0xd4, 0x00, 0x78, 0xe0,
    0x43, 0x05, 0x7b, 0xfe, 0xd8, 0x28, 0x04, 0x1a, 0xe0, 0x47, 0x13, 0x0e,
    0x1c, 0xcd, 0xa7, 0x00, 0xaf, 0x90, 0xe0, 0x43, 0x05, 0x0e, 0x1c, 0xcd,
    0xa7, 0x00, 0xaf, 0xb0, 0x20, 0xe0, 0xe0, 0x43, 0x3e, 0x83, 0xcd, 0x9f,
    0x00, 0x0e, 0x27, 0xcd, 0xa7, 0x00, 0x3e, 0xc1, 0xcd, 0x9f, 0x00, 0x11,
    0x8a, 0x01, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x1b, 0x7a, 0xb3, 0x20,
    0xf5, 0x18, 0x49, 0x0e, 0x13, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xc9, 0xf0,
    0x44, 0xfe, 0x90, 0x20, 0xfa, 0x0d, 0x20, 0xf7, 0xc9, 0x78, 0x22, 0x04,
    0x0d, 0x20, 0xfa, 0xc9, 0x47, 0x0e, 0x04, 0xaf, 0xc5, 0xcb, 0x10, 0x17,
    0xc1, 0xcb, 0x10, 0x17, 0x0d, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9,
    0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c, 0x00, 0x54, 0xa8, 0xfc,
    0x42, 0x4f, 0x4f, 0x54, 0x49, 0x58, 0x2e, 0x44, 0x4d, 0x47, 0x20, 0x76,
    0x31, 0x2e, 0x32, 0x00, 0x3e, 0xff, 0xc6, 0x01, 0x0b, 0x1e, 0xd8, 0x21,
    0x4d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3e, 0x01, 0xe0, 0x50};

// ================ HELPER FUNCTIONS ================

bool check_flag(int flag) {
  switch (flag) {
  case Z:
    return (regs[AF].low & 0x80);
  case N:
    return (regs[AF].low & 0x40);
  case H:
    return (regs[AF].low & 0x20);
  case C:
    return (regs[AF].low & 0x10);
  default:
    fprintf(stderr, "check_flag() got an incorrect flag int (flags are 0-3 in the Flags enum)\n");
    return false;
  }
}

void set_zero_flag(bool f) {
  if (f)
    regs[AF].low |= 0x80;
  else
    regs[AF].low &= ~0x80;
}

void set_subtraction_flag(bool f) {
  if (f)
    regs[AF].low |= 0x40;
  else
    regs[AF].low &= ~0x40;
}

void set_half_carry_flag(bool f) {
  if (f)
    regs[AF].low |= 0x20;
  else
    regs[AF].low &= ~0x20;
}

void set_carry_flag(bool f) {
  if (f)
    regs[AF].low |= 0x10;
  else
    regs[AF].low &= ~0x10;
}

void write16(uint16_t addr, uint16_t value) {
  if (addr < 0x4000)
    ;
  else if (addr < 0x8000)
    ;
  else if (addr < 0xA000)
    ;
  else if (addr < 0xC000)
    ;
  else if (addr < 0xD000)
    ;
  else if (addr < 0xE000)
    ;
  else if (addr < 0xFE00)
    ;
  else if (addr < 0xFEA0)
    ;
  else if (addr < 0xFF00)
    ;
  else if (addr < 0xFF80)
    ;
  else if (addr < 0xFFFF)
    ;
  else
    ;
}

void write8(uint16_t addr, uint8_t value) {
  if (addr < 0x4000)
    ;
  else if (addr < 0x8000)
    ;
  else if (addr < 0xA000)
    ;
  else if (addr < 0xC000)
    ;
  else if (addr < 0xD000)
    ;
  else if (addr < 0xE000)
    ;
  else if (addr < 0xFE00)
    ;
  else if (addr < 0xFEA0)
    ;
  else if (addr < 0xFF00)
    ;
  else if (addr < 0xFF80)
    ;
  else if (addr < 0xFFFF)
    ;
  else
    ;
}

uint16_t read16(uint16_t addr) {
  if (addr < 0x4000)
    ;
  else if (addr < 0x8000)
    ;
  else if (addr < 0xA000)
    ;
  else if (addr < 0xC000)
    ;
  else if (addr < 0xD000)
    ;
  else if (addr < 0xE000)
    ;
  else if (addr < 0xFE00)
    ;
  else if (addr < 0xFEA0)
    ;
  else if (addr < 0xFF00)
    ;
  else if (addr < 0xFF80)
    ;
  else if (addr < 0xFFFF)
    ;
  else
    ;

  return 0;
}

uint8_t read8(uint16_t addr) {
  if (addr < 0x4000)
    ;
  else if (addr < 0x8000)
    ;
  else if (addr < 0xA000)
    ;
  else if (addr < 0xC000)
    ;
  else if (addr < 0xD000)
    ;
  else if (addr < 0xE000)
    ;
  else if (addr < 0xFE00)
    ;
  else if (addr < 0xFEA0)
    ;
  else if (addr < 0xFF00)
    ;
  else if (addr < 0xFF80)
    ;
  else if (addr < 0xFFFF)
    ;
  else
    ;

  return 0;
}

// ================ OPCODES ================

// https://rgbds.gbdev.io/docs/v0.9.2/gbz80.7
// naming is instruction_destination_source
// r8 - 8 bit register, r16 - 16 bit
// HL, A, C, SP - hard set registers
// a16 == [r16], addr16 == [n16]
// aHL = [HL], aC = [C]

// The prefix instructions have one less PC increment
// than in the documentation, because I increment the PC
// when the prefix gets toggled.
// So, if the documentation says "bytes: 2," then I
// increment the PC by one, since I already incremented
// it before (at 0xCB no-prefix)

// ================ LOADS ================

void ld_r8_r8(uint8_t *dest, uint8_t *src) {
  *dest = *src;

  regs[PC].full += 1;
  cycle += 1;
}

void ld_r16_n16(uint16_t *dest, uint16_t src) {
  *dest = src;

  regs[PC].full += 3;
  cycle += 3;
}

void ld_aHL_r8(uint8_t *src) {
  write8(regs[HL].full, *src);

  regs[PC].full += 1;
  cycle += 2;
}

void ld_aHL_n8(uint8_t src);

void ld_r8_aHL(uint8_t *dest) {
  *dest = read8(regs[HL].full);

  regs[PC].full += 1;
  cycle += 2;
}

void ld_a16_A(uint16_t *dest) {
  // TODO: need this one for the serial write - I need to copy it
  // if (*dest < 0x4000)
  //   ;
  // else if (*dest < 0x8000)
  //   ;
  // else if (*dest < 0xA000)
  //   ;
  // else if (*dest < 0xC000)
  //   ;
  // else if (*dest < 0xD000)
  //   ;
  // else if (*dest < 0xE000)
  //   ;
  // else if (*dest < 0xFE00)
  //   ;
  // else if (*dest < 0xFEA0)
  //   ;
  // else if (*dest < 0xFF00)
  //   ;
  // else if (*dest < 0xFF80) {
  //   io_registers[*dest - IO_BASE] = regs[AF].high;
  //   if (*dest == SERIAL_TRANSFER)
  //     printf("%c", regs[AF].high);
  // } else if (*dest < 0xFFFF)
  //   ;
  // else
  //   ;

  write8(*dest, regs[AF].high);

  regs[PC].full += 1;
  cycle += 2;
}

void ld_addr16_A(uint16_t dest);
void ldh_addr16_A(uint16_t dest);
void ldh_aC_A();
void ld_A_a16(uint16_t *src);
void ld_A_addr16(uint16_t src);
void ldh_A_addr16(uint16_t src);
void ldh_A_aC();
void ld_aHLi_A();

void ld_aHLd_A() {
  write8(regs[HL].full, regs[AF].high);
  --regs[HL].full;

  regs[PC].full += 1;
  cycle += 2;
}

void ld_A_aHLi();
void ld_A_aHLd();

void ld_SP_n16(uint16_t src) {
  regs[SP].full = src;

  regs[PC].full += 3;
  cycle += 3;
}

void ld_addr16_SP(uint16_t dest) {
  write16(dest, regs[SP].full);

  regs[PC].full += 3;
  cycle += 5;
}

void ld_aHL_SPe8();
void ld_SP_aHL();

// ================ BITWISE ================

void xor_A_r8(uint8_t *src) {
  regs[AF].high ^= *src;

  regs[AF].high == 0 ? set_zero_flag(true) : set_zero_flag(false);
  set_subtraction_flag(false);
  set_half_carry_flag(false);
  set_carry_flag(false);

  regs[PC].full += 1;
  cycle += 1;
}

// ================ BIT FLAGS ================

void bit_u3_r8(int bit_num, uint8_t *src) {
  *src & (1 << bit_num) ? set_zero_flag(false) : set_zero_flag(true);

  set_subtraction_flag(false);
  set_half_carry_flag(true);

  regs[PC].full += 1;
  cycle += 2;
}

void bit_u3_aHL(int bit_num) {

  read8(regs[HL].full) & (1 << bit_num) ? set_zero_flag(false) : set_zero_flag(true);

  set_subtraction_flag(false);
  set_half_carry_flag(true);

  regs[PC].full += 1;
  cycle += 2;
}

// ================ JUMPS ================

// TODO
void jr_n16(uint16_t dest) {
  cycle += 3;
}

void jr_cc_n16(uint16_t dest) {
}

// ================ INTERRUPTS ================

void int_di();
void int_ei();
// TODO: implement this one, since it's already used in main.c
void int_halt();

// ================ MISC ================

void nop() {
  regs[PC].full += 1;
  cycle += 1;
}
